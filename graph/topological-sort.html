<!doctype html>
<html>
<head>
    <base href="http://e-maxx-eng.github.io/"/>
    <title>Topological Sorting  - E-Maxx Algorithms</title>
    <script src="./js/jq.js"></script>
    <script src="./js/common.js"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    <link rel="stylesheet" href="./css/common.css"/>

    <!-- highlightjs for code highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/styles/xcode.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.3/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <!-- end highlightjs -->
</head>
<body>
<div id="container">
    <div id="navbar">
        <span id="title">
            MAXimal
        </span>
        <span id="menu">
            <a href="./index.html">Home</a>
        </span>
    </div>
<h1>Topological Sorting</h1>

<p>Given a directed graph with <code>n</code> vertices and <code>m</code> edges. You want to <strong>renumber the vertices</strong> so that every edge led from the top with a smaller number in the top with a large.</p>

<p>In other words, you want to find a permutation of the vertices <strong>(topological order)</strong> corresponding to the order defined by all edges of the graph.</p>

<p>Topological sort can be <strong>not only</strong> (for example, if the graph is empty; or if there are three such vertices <code>a</code>, <code>b</code>, <code>c</code>, what <code>a</code> is the way in <code>b</code> and in <code>c</code>, but neither <code>b</code> in <code>c</code> nor out <code>c</code> to <code>b</code> get them).</p>

<p>Topological sorting <strong>may not</strong> exist at all - if the graph contains cycles (because there is a contradiction: there is a path from one vertex to another, and Vice versa).</p>

<p>A <strong>common problem</strong> for topological sorting next.... There are n variables whose values are unknown to us. We know only about some pairs of variables, one variable less than the other. You want to check, is not controversial whether these inequalities, and if not, to give the variables in ascending order (if the answer to any issue). It is easy to notice that this is exactly the task is about finding a topological sort of the graph of <code>n</code> vertices.</p>

<h2>The Algorithm</h2>

<p>For the solution we will use a depth-first-search.</p>

<p>Assume that the graph is acyclic, i.e. there is a solution. What makes the depth? When you run out of some of the peaks <code>v</code> he tries to run along all edges emanating from <code>v</code>. Along those edges, the ends of which have already been previously visited, it doesn't pass, and along the rest goes and causes themselves from their ends.</p>

<p>Thus, by the time of the call, {\rm dfs}(v) all vertices that are reachable from <code>v</code> either directly (one edge), and indirectly (by the way) - all such vertices already visited. Therefore, if we at the time of exit from {\rm dfs}(v) add our peak in the beginning of a list, in the end, this list will get a <strong>topological sort</strong>.</p>

<p>These explanations can also be presented in a somewhat different light, through the concept of <strong>"time out"</strong> of depth. Output time for each vertex <code>v</code> is the point at which the finished challenge {\rm dfs}(v) the depth of it (the times, when you can zanemarivali from 1 before n). It is easy to understand that the depth-first-exit time of any vertex <code>v</code> is always greater than the exit time of all vertices reachable from it (since they were visited either before the call {\rm dfs}(v)or during it). Thus, the desired topological sort is sorting in descending order times out.</p>

<h2>Implementation</h2>

<p>Here is an implementation, assuming that the graph is acyclic, i.e. the desired topological sort exists. If necessary, check the graph on acyclicity easy to insert into the depth, as described in the article on depth.</p>

<p><code>C++</code> implementation <span class="toggle-code">Show/Hide</span></p>

<pre><code>int n; // number of vertices
vector&lt;int&gt; g[MAXN]; // count
bool used[MAXN];
vector&lt;int&gt; ans;

void dfs (int v) {
 used[v] = true;
    for (size_t i=0; i&lt;g[v].size(); ++i) {
        int to = g[v][i];
        if (!used[to])
 dfs (to);
    }
 ans.push_back (v);
}

void topological_sort() {
    for (int i=0; i&lt;n; ++i)
 used[i] = false;
 ans.clear();
    for (int i=0; i&lt;n; ++i)
        if (!used[i])
 dfs (i);
 reverse (ans.begin(), ans.end());
}
</code></pre>

<p>Here the constant <strong>MAXN</strong> value must be set equal to the maximum possible number of vertices in the graph.</p>

<p>The main function of the solution is topological_sort, it initializes marking depth, starts it, and answer the result in the vector \rm ans.</p>

<h2>Challenges in online judges</h2>

<p>The task list in which you want to search topological sorting:</p>

<ul>
<li><a href="https://z5h64q92x9.net/proxy_u/ru-en.en/uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1246">UVA #10305 "Ordering Tasks" [difficulty: easy]</a></li>
<li><a href="https://z5h64q92x9.net/proxy_u/ru-en.en/uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=60">UVA #124 "Following Orders" [difficulty: easy]</a></li>
<li><a href="https://z5h64q92x9.net/proxy_u/ru-en.en/uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=136">UVA #200 "Rare Order" [difficulty: easy]</a></li>
</ul>

    <div id="footer">
    (c) 2014 translation by <a href="http://github.com/e-maxx-eng">http://github.com/e-maxx-eng</a>
    </div>
</div>
</body>
</html>
